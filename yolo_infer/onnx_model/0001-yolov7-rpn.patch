Subject: [PATCH] yolov7 rpn

---
 models/yolo.py     | 33 +++++++++++++++++-
 rpn_op/dec_bbox.py | 83 ++++++++++++++++++++++++++++++++++++++++++++++
 rpn_op/filter.py   | 42 +++++++++++++++++++++++
 rpn_op/nms.py      | 42 +++++++++++++++++++++++
 rpn_op/sort.py     | 43 ++++++++++++++++++++++++
 5 files changed, 242 insertions(+), 1 deletion(-)
 create mode 100644 rpn_op/dec_bbox.py
 create mode 100644 rpn_op/filter.py
 create mode 100644 rpn_op/nms.py
 create mode 100644 rpn_op/sort.py

diff --git a/models/yolo.py b/models/yolo.py
index 95a019c..21249b6 100644
--- a/models/yolo.py
+++ b/models/yolo.py
@@ -13,7 +13,10 @@ from utils.general import make_divisible, check_file, set_logging
 from utils.torch_utils import time_synchronized, fuse_conv_and_bn, model_info, scale_img, initialize_weights, \
     select_device, copy_attr
 from utils.loss import SigmoidBin
-
+from rpn_op.dec_bbox import DecBBox
+from rpn_op.filter import Filter
+from rpn_op.sort import Sort
+from rpn_op.nms import NMS
 try:
     import thop  # for FLOPS computation
 except ImportError:
@@ -38,8 +41,36 @@ class Detect(nn.Module):
         self.register_buffer('anchors', a)  # shape(nl,na,2)
         self.register_buffer('anchor_grid', a.clone().view(self.nl, 1, -1, 1, 1, 2))  # shape(nl,1,na,1,1,2)
         self.m = nn.ModuleList(nn.Conv2d(x, self.no * self.na, 1) for x in ch)  # output conv
+        self.anchors = anchors
+
+    def forward_with_rpn_op(self, x):
+        z = []  # inference output
+        # num_anchors 19200=80*80*3 4800=40*40*3 1200=20*20*3 3:anchor_num
+        self.box = [DecBBox(y=self.anchors[0],num_anchors=19200,num_coords=4,num_classes=self.nc,gridW=80,gridH=80,imgW=640,imgH=640,useClassId=1,calc_mode=5,clip_bbox=1,share_loc =1),
+                    DecBBox(y=self.anchors[1],num_anchors=4800,num_coords=4,num_classes=self.nc,gridW=40,gridH=40,imgW=640,imgH=640,useClassId=1,calc_mode=5,clip_bbox=1,share_loc=1),
+                    DecBBox(y=self.anchors[2],num_anchors=1200,num_coords=4,num_classes=self.nc,gridW=20,gridH=20,imgW=640,imgH=640,useClassId=1,calc_mode=5,clip_bbox=1,share_loc=1)]
+        self.filter = Filter(300, 0.9)
+        self.sort1 = Sort(300,0,self.nc)
+        self.nms = NMS(30,0.5)
+        for i in range(self.nl):
+            x[i] = self.m[i](x[i])  # conv
 
+            section = [self.no, self.no, self.no]
+            tmp_split = list(torch.split(x[i], section, 1))
+            tmp_split[0] = tmp_split[0].view(1, 1, self.no, -1)
+            tmp_split[1] = tmp_split[1].view(1, 1, self.no, -1)
+            tmp_split[2] = tmp_split[2].view(1, 1, self.no, -1)
+            tmp = torch.cat(tmp_split, 3)
+
+            bbox_result = self.box[i](tmp)
+            z.append(bbox_result)
+        out = torch.cat(z, 3)
+        filter_out = self.filter(out)
+        sort_out = self.sort1(filter_out)
+        out = self.nms(sort_out)
+        return out
     def forward(self, x):
+        return self.forward_with_rpn_op(x)
         # x = x.copy()  # for profiling
         z = []  # inference output
         self.training |= self.export
diff --git a/rpn_op/dec_bbox.py b/rpn_op/dec_bbox.py
new file mode 100644
index 0000000..2d51c00
--- /dev/null
+++ b/rpn_op/dec_bbox.py
@@ -0,0 +1,83 @@
+import unittest
+import torch
+import torch.utils.cpp_extension
+
+import onnx
+
+import numpy as np
+import io
+from torch.onnx.symbolic_helper import parse_args
+from torch.onnx import register_custom_op_symbolic
+from torch.onnx.symbolic_helper import _maybe_get_const
+import pickle
+
+op_source = """
+        #include <torch/script.h>
+        torch::Tensor DecBBox(torch::Tensor input0, torch::Tensor bias, int64_t num_anchors,
+            int64_t num_coords, int64_t num_classes, int64_t m_gridH, int64_t m_gridW, int64_t m_imgW, int64_t m_imgH,
+            int64_t useClassId, int64_t calc_mode,int64_t clip_box,int64_t share_loc, int64_t multi_label)
+        {
+            if ((calc_mode == 3 || calc_mode == 5) && multi_label == 0) {
+                return torch::zeros({1, 1, 5 + useClassId, input0.size(3)});
+            } else {
+                return torch::zeros({1, num_classes, 5 + useClassId, input0.size(3)});
+            }
+        }
+        static auto registry =
+            torch::RegisterOperators("custom_ops::DecBBox", &DecBBox);
+        """
+
+torch.utils.cpp_extension.load_inline(
+    name='DecBBox',
+    cpp_sources=op_source,
+    is_python_module=False,
+    verbose=True,
+    )
+
+@parse_args('v', 'v', 'i', 'i', 'i', 'i', 'i', 'i', 'i', 'i','i','i','i', 'i')
+def symbolic_decbbox(g, input, bias, num_anchors, num_coords, num_classes, gridH, gridW, imgW, imgH, useClassId, calc_mode, clip_bbox, share_loc, multi_label):
+    return g.op('custom_ops::DecBBox', input,  bias, num_anchors_i = num_anchors, num_coords_i = num_coords, num_classes_i = num_classes,
+                gridH_i = gridH, gridW_i = gridW, imgW_i = imgW, imgH_i = imgH, useClassId_i = useClassId, calc_mode_i = calc_mode,
+                clip_bbox_i = clip_bbox,share_loc_i = share_loc, multi_label_i = multi_label)
+from torch.onnx import register_custom_op_symbolic
+register_custom_op_symbolic('custom_ops::DecBBox', symbolic_decbbox, 9)
+
+class DecBBox(torch.nn.Module):
+    def __init__(self, y,num_anchors,num_coords,num_classes, gridH, gridW, imgW, imgH, useClassId, calc_mode,clip_bbox,share_loc, multi_label = 0):
+        super(DecBBox, self).__init__()
+        self.register_buffer('y', torch.tensor(y))
+        self.num_anchors = num_anchors
+        self.num_coords = num_coords
+        self.num_classes = num_classes
+        self.gridH = gridH
+        self.gridW = gridW
+        self.imgW = imgW
+        self.imgH = imgH
+        self.useClassId = useClassId
+        self.calc_mode = calc_mode
+        self.clip_bbox = clip_bbox
+        self.share_loc = share_loc
+        self.multi_label = multi_label
+    def forward(self, x):
+        return torch.ops.custom_ops.DecBBox(x,self.y,self.num_anchors, self.num_coords,self.num_classes, self.gridH,self.gridW,
+            self.imgW,self.imgH, self.useClassId, self.calc_mode,self.clip_bbox,self.share_loc, self.multi_label)
+
+# DecBBox2: for ssd & fastercnn with 2 inputs
+class DecBBox2(torch.nn.Module):
+    def __init__(self, num_anchors,num_coords,num_classes, gridH, gridW, imgW, imgH, useClassId, calc_mode,clip_bbox,share_loc):
+        super(DecBBox, self).__init__()
+        self.num_anchors = num_anchors
+        self.num_coords = num_coords
+        self.num_classes = num_classes
+        self.gridH = gridH
+        self.gridW = gridW
+        self.imgW = imgW
+        self.imgH = imgH
+        self.useClassId = useClassId
+        self.calc_mode = calc_mode
+        self.clip_bbox = clip_bbox
+        self.share_loc = share_loc
+        self.multi_label = 0
+    def forward(self, x, y):
+        return torch.ops.custom_ops.DecBBox(x, y, self.num_anchors, self.num_coords,self.num_classes, self.gridH,self.gridW,
+            self.imgW,self.imgH, self.useClassId, self.calc_mode,self.clip_bbox,self.share_loc, self.multi_label)
\ No newline at end of file
diff --git a/rpn_op/filter.py b/rpn_op/filter.py
new file mode 100644
index 0000000..981da4b
--- /dev/null
+++ b/rpn_op/filter.py
@@ -0,0 +1,42 @@
+import unittest
+import torch
+import torch.utils.cpp_extension
+
+import onnx
+
+import numpy as np
+import io
+from torch.onnx.symbolic_helper import parse_args
+from torch.onnx import register_custom_op_symbolic
+
+op_source = """
+        #include <torch/script.h>
+        torch::Tensor Filter(torch::Tensor in, int64_t topK, double m_lowScoreThresh)
+        {
+            return in;
+        }
+        static auto registry =
+            torch::RegisterOperators("custom_ops::Filter", &Filter);
+        """
+
+torch.utils.cpp_extension.load_inline(
+    name='Filter',
+    cpp_sources=op_source,
+    is_python_module=False,
+    verbose=True,
+    )
+
+@parse_args("v", "i", "f")
+def symbolic_filter(g, self, topK, conf_thres):
+    return g.op('custom_ops::Filter', self, topK_i=topK, low_score_thresh_f=conf_thres)
+from torch.onnx import register_custom_op_symbolic
+register_custom_op_symbolic('custom_ops::Filter', symbolic_filter, 9)
+
+class Filter(torch.nn.Module):
+    def __init__(self, topK, conf_thres):
+        super(Filter, self).__init__()
+        self.topK = topK
+        self.conf_thres = conf_thres
+
+    def forward(self, x):
+        return torch.ops.custom_ops.Filter(x, self.topK, self.conf_thres)
\ No newline at end of file
diff --git a/rpn_op/nms.py b/rpn_op/nms.py
new file mode 100644
index 0000000..385fb38
--- /dev/null
+++ b/rpn_op/nms.py
@@ -0,0 +1,42 @@
+import unittest
+import torch
+import torch.utils.cpp_extension
+
+import onnx
+
+import numpy as np
+import io
+from torch.onnx.symbolic_helper import parse_args
+from torch.onnx import register_custom_op_symbolic
+
+op_source = """
+        #include <torch/script.h>
+        torch::Tensor NMS(torch::Tensor in, int64_t topK, double nmsThresh)
+        {
+            return in;
+        }
+        static auto registry =
+            torch::RegisterOperators("custom_ops::NMS", &NMS);
+        """
+
+torch.utils.cpp_extension.load_inline(
+    name='NMS',
+    cpp_sources=op_source,
+    is_python_module=False,
+    verbose=True,
+    )
+
+@parse_args("v", "i", "f")
+def symbolic_nms(g, self, topK, nmsThresh):
+    return g.op('custom_ops::NMS', self, topK_i=topK, nms_thresh_f = nmsThresh)
+from torch.onnx import register_custom_op_symbolic
+register_custom_op_symbolic('custom_ops::NMS', symbolic_nms, 9)
+
+class NMS(torch.nn.Module):
+    def __init__(self, topK,nms_thresh):
+        super(NMS, self).__init__()
+        self.topK = topK
+        self.nms_thresh = nms_thresh
+
+    def forward(self, x):
+        return torch.ops.custom_ops.NMS(x, self.topK, self.nms_thresh)
\ No newline at end of file
diff --git a/rpn_op/sort.py b/rpn_op/sort.py
new file mode 100644
index 0000000..64921e5
--- /dev/null
+++ b/rpn_op/sort.py
@@ -0,0 +1,43 @@
+import unittest
+import torch
+import torch.utils.cpp_extension
+
+import onnx
+
+import numpy as np
+import io
+from torch.onnx.symbolic_helper import parse_args
+from torch.onnx import register_custom_op_symbolic
+
+op_source = """
+        #include <torch/script.h>
+        torch::Tensor Sort(torch::Tensor in, int64_t topK, int64_t isMultiSort, int64_t classNum)
+        {
+            return in;
+        }
+        static auto registry =
+            torch::RegisterOperators("custom_ops::Sort", &Sort);
+        """
+
+torch.utils.cpp_extension.load_inline(
+    name='Sort',
+    cpp_sources=op_source,
+    is_python_module=False,
+    verbose=True,
+    )
+
+@parse_args("v", "i", "i","i")
+def symbolic_sort(g, self, topK, multi_sort, class_num):
+    return g.op('custom_ops::Sort', self, topK_i=topK, multi_sort_i=multi_sort,class_num_i = class_num)
+from torch.onnx import register_custom_op_symbolic
+register_custom_op_symbolic('custom_ops::Sort', symbolic_sort, 9)
+
+class Sort(torch.nn.Module):
+    def __init__(self, topK, multi_sort, class_num):
+        super(Sort, self).__init__()
+        self.topK = topK
+        self.multi_sort = multi_sort
+        self.class_num = class_num
+
+    def forward(self, x):
+        return torch.ops.custom_ops.Sort(x, self.topK, self.multi_sort, self.class_num)
-- 
2.17.1


Subject: [PATCH] yolov8 rpn

---
 rpn_op/filter.py              | 44 +++++++++++++++++++++++++++++++++++
 rpn_op/sort.py                | 42 +++++++++++++++++++++++++++++++++
 ultralytics/nn/modules.py     | 25 +++++++++++++++-----
 ultralytics/yolo/utils/tal.py |  3 ++-
 4 files changed, 107 insertions(+), 7 deletions(-)
 create mode 100644 rpn_op/filter.py
 create mode 100644 rpn_op/sort.py

diff --git a/rpn_op/filter.py b/rpn_op/filter.py
new file mode 100644
index 00000000..72e18b86
--- /dev/null
+++ b/rpn_op/filter.py
@@ -0,0 +1,44 @@
+import unittest
+import torch
+import torch.utils.cpp_extension
+
+import onnx
+
+import numpy as np
+import io
+from torch.onnx.symbolic_helper import parse_args
+from torch.onnx import register_custom_op_symbolic
+
+op_source = """
+        #include <torch/script.h>
+        torch::Tensor FilterVector(torch::Tensor in, int64_t topK, double filterThresh, int64_t isOutputIdx, int64_t isReportVectorNum)
+        {
+            return in;
+        }
+        static auto registry =
+            torch::RegisterOperators("custom_ops::FilterVector", &FilterVector);
+        """
+
+torch.utils.cpp_extension.load_inline(
+    name='FilterVector',
+    cpp_sources=op_source,
+    is_python_module=False,
+    verbose=True,
+    )
+
+@parse_args("v", "i", "f", "i", "i")
+def symbolic_filter(g, self, top_k, filter_thresh, is_output_idx, is_report_vector_num):
+    return g.op('custom_ops::FilterVector', self, top_k_i=top_k, filter_thresh_f=filter_thresh,
+        is_output_idx_i=is_output_idx, is_report_vector_num_i=is_report_vector_num)
+from torch.onnx import register_custom_op_symbolic
+register_custom_op_symbolic('custom_ops::FilterVector', symbolic_filter, 9)
+
+class FilterVector(torch.nn.Module):
+    def __init__(self, top_k, filter_thresh, is_output_idx, is_report_vector_num):
+        super(FilterVector, self).__init__()
+        self.top_k = top_k
+        self.filter_thresh = filter_thresh
+        self.is_output_idx = is_output_idx
+        self.is_report_vector_num = is_report_vector_num
+    def forward(self, x):
+        return torch.ops.custom_ops.FilterVector(x, self.top_k, self.filter_thresh, self.is_output_idx, self.is_report_vector_num)
\ No newline at end of file
diff --git a/rpn_op/sort.py b/rpn_op/sort.py
new file mode 100644
index 00000000..a08d57b3
--- /dev/null
+++ b/rpn_op/sort.py
@@ -0,0 +1,42 @@
+import unittest
+import torch
+import torch.utils.cpp_extension
+
+import onnx
+
+import numpy as np
+import io
+from torch.onnx.symbolic_helper import parse_args
+from torch.onnx import register_custom_op_symbolic
+
+op_source = """
+        #include <torch/script.h>
+        torch::Tensor SortVector(torch::Tensor in, int64_t topK, int64_t isOutputIdx, int64_t isReportVectorNum)
+        {
+            return in;
+        }
+        static auto registry =
+            torch::RegisterOperators("custom_ops::SortVector", &SortVector);
+        """
+
+torch.utils.cpp_extension.load_inline(
+    name='SortVector',
+    cpp_sources=op_source,
+    is_python_module=False,
+    verbose=True,
+    )
+
+@parse_args("v", "i", "i", "i")
+def symbolic_filter(g, self, top_k, is_output_idx, is_report_vector_num):
+    return g.op('custom_ops::SortVector', self, top_k_i=top_k, is_output_idx_i=is_output_idx, is_report_vector_num_i=is_report_vector_num)
+from torch.onnx import register_custom_op_symbolic
+register_custom_op_symbolic('custom_ops::SortVector', symbolic_filter, 9)
+
+class SortVector(torch.nn.Module):
+    def __init__(self, top_k, is_output_idx, is_report_vector_num):
+        super(FilterVector, self).__init__()
+        self.top_k = top_k
+        self.is_output_idx = is_output_idx
+        self.is_report_vector_num = is_report_vector_num
+    def forward(self, x):
+        return torch.ops.custom_ops.SortVector(x, self.top_k, self.is_output_idx, self.is_report_vector_num)
\ No newline at end of file
diff --git a/ultralytics/nn/modules.py b/ultralytics/nn/modules.py
index ee21d79f..af9d7576 100644
--- a/ultralytics/nn/modules.py
+++ b/ultralytics/nn/modules.py
@@ -77,8 +77,12 @@ class DFL(nn.Module):
         self.c1 = c1
 
     def forward(self, x):
-        b, c, a = x.shape  # batch, channels, anchors
-        return self.conv(x.view(b, 4, self.c1, a).transpose(2, 1).softmax(1)).view(b, 4, a)
+        #b, c, a = x.shape  # batch, channels, anchors
+        #return self.conv(x.view(b, 4, self.c1, a).transpose(2, 1).softmax(1)).view(b, 4, a)
+        b = 1
+        c1 = 16
+        a = 8400
+        return self.conv(x.view(b, 4, c1, a).transpose(2, 1).softmax(1)).view(b, 4, a)
         # return self.conv(x.view(b, self.c1, 4, a).softmax(1)).view(b, 4, a)
 
 
@@ -380,7 +384,6 @@ class Ensemble(nn.ModuleList):
 
 # Model heads below ----------------------------------------------------------------------------------------------------
 
-
 class Detect(nn.Module):
     # YOLOv8 Detect head for detection models
     dynamic = False  # force grid reconstruction
@@ -418,9 +421,19 @@ class Detect(nn.Module):
             cls = x_cat[:, self.reg_max * 4:]
         else:
             box, cls = x_cat.split((self.reg_max * 4, self.nc), 1)
-        dbox = dist2bbox(self.dfl(box), self.anchors.unsqueeze(0), xywh=True, dim=1) * self.strides
-        y = torch.cat((dbox, cls.sigmoid()), 1)
-        return y if self.export else (y, x)
+        dbox = dist2bbox(self.dfl(box), self.anchors.unsqueeze(0), xywh=False, dim=1) * self.strides
+        dbox = dbox.view(1, 1, 4, -1)
+        cls = cls.view(1, 1, self.nc, -1)
+        max_score, max_class_id = cls.max(2, keepdim=True)
+        max_score = max_score.sigmoid()
+        max_score_copy = max_score.clone()
+        from rpn_op.filter import FilterVector
+        from rpn_op.sort import SortVector
+        self.filter_val = FilterVector(300, 0.8, 0, 1)
+        self.filter_idx = FilterVector(300, 0.8, 1, 0)
+        filter_result0 = self.filter_val(max_score)
+        filter_result1 = self.filter_idx(max_score_copy)
+        return filter_result0,filter_result1,dbox,max_class_id
 
     def bias_init(self):
         # Initialize Detect() biases, WARNING: requires stride availability
diff --git a/ultralytics/yolo/utils/tal.py b/ultralytics/yolo/utils/tal.py
index 0b714144..c96c8bfb 100644
--- a/ultralytics/yolo/utils/tal.py
+++ b/ultralytics/yolo/utils/tal.py
@@ -206,7 +206,8 @@ def make_anchors(feats, strides, grid_cell_offset=0.5):
 
 def dist2bbox(distance, anchor_points, xywh=True, dim=-1):
     """Transform distance(ltrb) to box(xywh or xyxy)."""
-    lt, rb = distance.chunk(2, dim)
+    #lt, rb = distance.chunk(2, dim)
+    lt, rb = torch.split(distance,2, 1)
     x1y1 = anchor_points - lt
     x2y2 = anchor_points + rb
     if xywh:
-- 
2.17.1

